func nextGreaterElement(nums1 []int, nums2 []int) []int {
//     hashMap := make(map[int]int)

//     var greaterElem int
//     for i:=len(nums2)-1;i>=0;i--{
//         if i==len(nums2)-1 {
//            // last element next greater would be always -1 
//            hashMap[nums2[i]] = -1 
//            greaterElem = nums2[i]
//         } else if nums2[i+1] > nums2[i]{
//            hashMap[nums2[i]] =  nums2[i+1]
//            greaterElem = nums2[i+1]
//         } else if  nums2[i+1] < nums2[i] && greaterElem > nums2[i]{
//             hashMap[nums2[i]] =  greaterElem
//         } else {
//             hashMap[nums2[i]] = -1
//         }

//     }
//     fmt.Println(hashMap)
//     var result []int
//     for _, num := range nums1{
//         elem, ok := hashMap[num]
//         if ok {
//             result = append(result,elem)
//         }
//     }

//     return result
// }



func nextGreaterElement(nums1 []int, nums2 []int) []int {
    hashMap := make(map[int]int)
    var stack []int

    stack = append(stack,nums2[len(nums2)-1])
    hashMap[nums2[len(nums2)-1]] = -1

    for i:=len(nums2)-2;i>=0;i--{
        if nums2[i] < nums2[i+1]{
            hashMap[nums2[i]] = nums2[i+1]
            stack = append(stack,nums2[i])
        } else {
            if len(stack) > 0 {
             for _, _ = range stack{
                top := stack[len(stack)-1]
                if top > nums2[i]{
                    hashMap[nums2[i]] = top
                    break
                } else {
                    stack = stack[:len(stack)-1]
                }
             }
            }
            
            if len(stack) <=0 {
                hashMap[nums2[i]] = -1
            } 
        }

        stack = append(stack, nums2[i])
    }

    var result []int
    for _, num := range nums1{
        elem, ok := hashMap[num]
        if ok {
            result = append(result,elem)
        }
    }

    return result
}
